We used an external macros called uthash to generate the data structure that stores the words and their filename. We assume for our implementation that the inverted index file being read is in the suggested format as generated by our indexer.c. First, we parse the inverted-index file and place the words in a hashtable, as the keys. The values of each key is a linked list of the filenames and their frequencies. After generating the hashtable we have an infite while loop for constant querying until the user enters "q". The functions called for each valid search query are specific to an so or an sa search.

The indexFiles function parses the inverted index file and generates a hash table data structure to hold the words and their file names. An outer loop reads the file line by line. Depending on the first token of the line, the inner loop reads the tokens within the line and decides what to do with them. Despite an inner loop, in the end, each token is read once, and that makes up the running time of the function. The worst case and best case running time will be the same. Therefore, the big oh running time of the function is O(m) where m is the number of tokens in the inverted index file. This function is called only once in each instance of the program. 

The main function does the constant querying. Once the user enters sa/so and some words, the while loop tokenizes the line and calls the appropriate function (SO or SA) on each term in the query. The best case running time for main is big O (1). This occurs when the user enters q on the first query. The worst case running time is big O(n * k), where k is the number of searches the user completes and n is the number of words in the query. 

Therefore, the big oh for the program is O(nk + m), since we do not know whether nk or m will be smaller.

As for memory requirements, memory was dynamically allocated for the words that are keys in the hashtable and for their values, which are linked list of records with the file names and their frequencies. Dynamic memory was also used to create an array of char* that keep track of the user inputted command and words. The char* in the array were malloced and each index stored a token. This was freed at the end of a query , after the output is printed. In addition, we used two linked lists to keep track of the files to be printed for the sa or so command. These are freed after the contents are printed. After the user enters q, we free the memory by going through the hashtable and freeing the linked lists and the keys. In addition, we free the malloced linked lists for sa or so and we free any malloced strings. 
