The worst case and best case running time of the SLCreate function is big O(1) because the function mallocs once per list creation. The memory usage is very small because it is only mallocing at most one struct. 

The running time of SLDestroy is big O(n) because you must traverse the whole linked list to free every node in the list. The memory used in this function increases the total memory available because the purpose of this function is to free malloced memory. 

This function SLInsert works by checking if the data in the list is higher, lower, or equal to the data that is to be inserted. The running time of SLInsert is worst case big O(n) because you must traverse the linked list and check for duplicates and then insert at the end of the list. The best case big O is O(1) because that is when the list is NULL or any time you insert at the head. The memory used in this function is at most the size of one struct because you create at mose one node to be inserted into the list. 

The function SLRemove works by traversing the linked list and comparing the data in each node to the newObj variable. If the data is equal to 0, then you decrement the number of pointers to the node and remove the item from the list. The best case big O running time is O(1) becuase that is when the list is NULL or you remove the head of the linked list. The worst case running time occurs when you traverse the linked list and the item to be removed is not in the liinked list. This results in the running time of big O(n). There is no permanent memory used in this function because no data is malloced, but there is some memory that is freed. As a result, the total memory available increases. 

The function SLCreateIterator
